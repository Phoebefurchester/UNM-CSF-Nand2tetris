// PART 2 (TASK B) CPU

/*
    The Central Processing unit (CPU).
    Consists of an ALU and a set of registers, designed to fetch and 
    execute instructions written in the Hack machine language.
    In particular, functions as follows:
    Executes the inputted instruction according to the Hack machine 
    language specification. The D and A in the language specification
    refer to CPU-resident registers, while M refers to the external
    memory location addressed by A, i.e. to Memory[A]. The inM input 
    holds the value of this location. If the current instruction needs 
    to write a value to M, the value is placed in outM, the address 
    of the target location is placed in the addressM output, and the 
    writeM control bit is asserted. (When writeM = 0, any value may 
    appear in outM). The outM and writeM outputs are combinational: 
    they are affected instantaneously by the execution of the current 
    instruction. The addressM and pc outputs are clocked: although they 
    are affected by the execution of the current instruction, they commit 
    to their new values only in the next time unit. If reset = 1 then the 
    CPU jumps to address 0 (i.e. sets pc = 0 in next time unit) rather 
    than to the address resulting from executing the current instruction.
*/

 CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset = 1) or continue executing
                         // the current program (reset = 0).

    OUT outM[16],        // M value output
        writeM,          // Write into M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    // Implement the CPU based on its following functionalities


    // Instruction decode
    Mux16(a = false, b = instruction, sel = instruction[15], 
        out[0] = JGT, 
        out[1] = JEQ, 
        out[2] = JLT, 
        out[3] = writeM, // destM
        out[4] = destD, 
        out[5] = destA,
        out[6] = NO, 
        out[7] = F, 
        out[8] = NY, 
        out[9] = ZY, 
        out[10] = NX, 
        out[11] = ZX, 
        out[12] = AorM, 
        // 13 and 14 bits are unused
        out[15] = Cins);

    // A register and input mux
    Mux16(a = instruction, b = aluoutput, sel = Cins, out = Aregin);
    ARegister(in = Aregin, load = Aregload, out = Aregoutput, out[0..14] = addressM);

    // A register's load logic
    // destA or A instruction
    Not(in = Cins, out = notCins);
    Or(a = notCins, b = destA, out = Aregload);

    // D register
    DRegister(in = aluoutput, load = destD, out = Dregoutput);
    
    // ALU and input mux
    // select output from A register or input from memory
    Mux16(a = Aregoutput, b = inM, sel = instruction[12], out = yinput);
    ALU(x = Dregoutput, y = yinput, zx = ZX, nx = NX, zy = ZY, ny = NY, f = F, no = NO, out = aluoutput, out = outM, zr = ZR, ng = NG);
 
    // PC with jump test
    Or(a = ZR, b = NG, out = ZRNG);
    Not(in = ZRNG, out = NotZRNG);

    And(a = JLT, b = NG, out = Andout1);
    And(a = JEQ, b = ZR, out = Andout2);
    And(a = JGT, b = NotZRNG, out = Andout3);
    Or(a = Andout1, b = Andout2, out = Orout1);
    Or(a = Orout1, b = Andout3, out = Orout2);
    
    PC(in = Aregoutput, load = Orout2, inc = true, reset = reset, out[0..14] = pc);
}
